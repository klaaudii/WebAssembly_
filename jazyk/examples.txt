//1 TODO cons!
(define (is-even? n)
  (= (remainder n 2) 0))

(define (filter predicate lst)
  (cond ((null? lst) '())
        ((predicate (car lst))
         (cons (car lst) (filter predicate (cdr lst))))
        (else
         (filter predicate (cdr lst)))))

(define numbers '(1 2 3 4 5 6 7 8 9 10))

(define evens (filter is-even? numbers))
(display evens)


//////////////////////////////////taketo zakladne lambdy idu
(define f (lambda (a b) (+ a b)))
(display (f 10 20))



//kludne prihod priklad na redukciu (asi lepsie na filter)... teda ze mozeme poslat + * / -
(define (red a b f) (f a b))
(display ( + (red 10 20 (lambda (a b) (+ a b)))))


/////////////////////////////////////tieto dve lambdy nejdu... na to treba vlastny menny priestor
(define (f a) (lambda (b) (+ a b)))
(f 5)

(define (f a) (lambda (b) (+ a b)))
(define z (f 5))
(z 3)
 ///////////////////////////////////

 (define sum3
 (lambda (a b c)
 (+ a b c)))


 (define (red a b f) (f a b))
 (display ( + (red 10 20 (lambda (a b) (+ a b))) (red 10 20 (lambda (a b) (* a b))) (red 10 20 (lambda (a b) (* a b)))))

(define (innerloop j i)
(if (< j 3)
(begin
(display (list i j))
(innerloop (+ j 1) i))))
(define (outerloop i)
(if (< i 5)
(begin
(innerloop 0 i)
(outerloop (+ i 1)))))
(outerloop 0)


(define (last-element l)
(if (null? (cdr l)) (car l) (last-element (cdr l)))
)
(display (last-element (list 10 50 70 80 7 (list 7 8))))



(define (length lis)
(if (null? lis)
0
(+ 1 (length (cdr lis)))))
(display (length (list 10 20)))


(define (fib3 n a b) (if (<= n 2) a (fib3 (- n 1) (+ a b) a)))
(define (fib2 n) (fib3 n 1 1))
(fib2 7)

(define (fib n)
(if (<= n 2) 1 (+ (fib (- n 1)) (fib (- n 2)))))

(display (+ (vector 1 2 3) (vector 1 2 3 4)))



(define (fib2 n)
(fib3 n 1 1)
)

(define (fib3 n a b) (if (<= n 2) a (fib3 (- n 1) (+ a b) a)))




(fib2 6)


(define (fib3 n a b) (if (<= n 2) a (fib3 (- n 1) (+ a b) a)))

(define (fib2 n) (fib3 n 1 1))

(fib2 7)





//////////////////////////////////////
(define a 20)
(define b a)
(define c (+ 4 5))
(define d (+ b a))
(define l (list (list 1 2) 3 4))
(define l2 (list 1 2 3))
(define l4 (list b 2 3))
(define l3 (car l4))
(define (f a b) (/ a b))
(define y (f 10 20))
(define v (vector 1 2))
(define x (vector-ref v 1))
(display a)
(display b)
(display c)
(display d)
(display l)
(display l2)
(display l4)
(display l3)
(display y)
(display v)
(display x)





(define (fib3 n a b) (if (<= n 2) a (fib3 (- n 1) (+ a b) a)))
(define (fib2 n) (fib3 n 1 1))
(display (fib2 7))


//////////////////////////////////////


grammar SchemeLikeL;

start: SPACE? (expr | defineGlobalVar | defineFnc | literal | identifier | callFnc | setExpr | listExpr | displayExpr)+ EOF;

expr: SPACE? PSTART SPACE? operatorExpr (SPACE (expr | literal | identifier | callFnc ))* SPACE? PEND SPACE?;
defineGlobalVar: SPACE? PSTART SPACE? 'define' SPACE identifier (SPACE (expr | literal | identifier | callFnc | vectorExpr | listExpr))* SPACE? PEND SPACE?;
defineFnc: SPACE? PSTART SPACE? 'define' SPACE
        ((PSTART identifier':'type (SPACE identifier':'type)* SPACE? PEND SPACE? (fncBodyExpr | localFncBodyExpr) PEND) |
        (identifier':'type SPACE? PSTART SPACE? 'lambda' SPACE? PSTART SPACE? identifier? (SPACE identifier)* SPACE? PEND
        SPACE? fncBodyExpr PEND PEND));
biExpr: SPACE? PSTART SPACE? biOperatorExpr SPACE (biExpr | expr | literal | identifier | callFnc) SPACE
        (biExpr | expr | literal | identifier | callFnc) SPACE? PEND SPACE?;
uniExpr: SPACE? PSTART SPACE? uniOperatorExpr SPACE (literal | identifier | expr | callFnc) SPACE? PEND SPACE?;


callFnc: SPACE? PSTART SPACE? identifier (SPACE (identifier | literal  | callFnc | expr | callLambdaFnc | listExpr))* SPACE? PEND SPACE?;
callLambdaFnc: SPACE? PSTART SPACE? 'lambda' SPACE? PSTART SPACE? identifier? (SPACE identifier)* SPACE? PEND
                       SPACE? ((expr | callFnc) SPACE?)+ PEND SPACE?;
ifExpr: SPACE? PSTART SPACE? 'if' SPACE (expr | biExpr | literal | identifier | callFnc | uniExpr)
        SPACE? ((expr | literal | identifier | callFnc | setExpr) | beginExpr)
        (SPACE? ((expr | literal | identifier | callFnc | setExpr) | beginExpr))? SPACE? PEND SPACE?;

beginExpr: SPACE? PSTART SPACE? 'begin' SPACE?  (expr | literal | identifier | callFnc | setExpr | loopExpr)+  SPACE? PEND SPACE?;

operatorExpr: OPERATOR;
biOperatorExpr: BIOPERATOR;
uniOperatorExpr: UNIOPERATOR;
localFncBodyExpr: SPACE? PSTART SPACE? 'let' SPACE? PSTART SPACE? ((PSTART SPACE? varPairExpr SPACE? PEND) SPACE?)* PEND
               SPACE? fncBodyExpr SPACE? PEND SPACE?;

fncBodyExpr: SPACE? ((expr | callFnc | ifExpr | setExpr | loopExpr | listExpr) SPACE?)+ SPACE?;
varPairExpr: SPACE? identifier SPACE (expr | literal | identifier | callFnc | vectorExpr | listExpr) SPACE?;

setExpr: SPACE? PSTART SPACE? 'set!' SPACE varPairExpr SPACE? PEND SPACE?;
loopExpr: SPACE? PSTART SPACE? 'let' SPACE identifier SPACE? PSTART SPACE? ((PSTART SPACE? varPairExpr SPACE? PEND) SPACE?)* PEND
          SPACE? fncBodyExpr SPACE? PEND SPACE? ;

vectorExpr: SPACE? PSTART SPACE? 'vector' (SPACE (literal | identifier | expr))+ SPACE? PEND SPACE? ;

listExpr: SPACE? PSTART SPACE? 'list' (SPACE (literal | identifier | vectorExpr | listExpr  | expr))+ SPACE? PEND SPACE? ;

displayExpr: SPACE? PSTART SPACE? 'display' SPACE (literal | identifier | vectorExpr | listExpr | callFnc | expr) SPACE? PEND SPACE? ;

literal: FLOAT | INT;
identifier: VARIABLE;
type: 'num' | 'list' | 'vec' | 'none';

OPERATOR: [+*/-];
BIOPERATOR: '=' | '<=' | '>=' | '<' | '>' | '!=' | 'and' | 'or';
UNIOPERATOR: 'null?';
VARIABLE: [a-zA-Z][a-zA-Z-!]*[0-9]*;
PSTART: '(';
PEND: ')';
SPACE: [ ]+;
FLOAT: [0-9]+ '.' [0-9]+;
INT: [0-9]+;
WS: [ \t\r\n]+ -> skip;


///////////////////////////////////////////////////////////// S LOOPOM

grammar SchemeLikeL;

start: SPACE? (expr | defineGlobalVar | defineFnc | literal | identifier | callFnc | setExpr | listExpr | vectorExpr | displayExpr)+ EOF;

expr: SPACE? PSTART SPACE? operatorExpr (SPACE (expr | literal | identifier | callFnc ))* SPACE? PEND SPACE?;
defineGlobalVar: SPACE? PSTART SPACE? 'define' SPACE identifier (SPACE (expr | literal | identifier | callFnc | vectorExpr | listExpr))* SPACE? PEND SPACE?;
defineFnc: SPACE? PSTART SPACE? 'define' SPACE
        ((PSTART identifier (SPACE identifier)* SPACE? PEND SPACE? (fncBodyExpr | localFncBodyExpr) PEND) |
        (identifier SPACE? PSTART SPACE? 'lambda' SPACE? PSTART SPACE? identifier? (SPACE identifier)* SPACE? PEND
        SPACE? fncBodyExpr PEND PEND));
biExpr: SPACE? PSTART SPACE? biOperatorExpr SPACE (biExpr | expr | literal | identifier | callFnc) SPACE
        (biExpr | expr | literal | identifier | callFnc) SPACE? PEND SPACE?;
uniExpr: SPACE? PSTART SPACE? uniOperatorExpr SPACE (literal | identifier | expr | callFnc) SPACE? PEND SPACE?;


callFnc: SPACE? PSTART SPACE? identifier (SPACE (identifier | literal  | callFnc | expr | callLambdaFnc | listExpr | vectorExpr))* SPACE? PEND SPACE?;
callLambdaFnc: SPACE? PSTART SPACE? 'lambda' SPACE? PSTART SPACE? identifier? (SPACE identifier)* SPACE? PEND
                       SPACE? ((expr | callFnc) SPACE?)+ PEND SPACE?;
ifExpr: SPACE? PSTART SPACE? 'if' SPACE (expr | biExpr | literal | identifier | callFnc | uniExpr)
        SPACE? ((expr | literal | identifier | callFnc | setExpr | loopExpr) | beginExpr)
        (SPACE? ((expr | literal | identifier | callFnc | setExpr | loopExpr) | beginExpr))? SPACE? PEND SPACE?;

beginExpr: SPACE? PSTART SPACE? 'begin' SPACE?  (expr | literal | identifier | callFnc | setExpr | loopExpr | displayExpr | ifExpr)+  SPACE? PEND SPACE?;

operatorExpr: OPERATOR;
biOperatorExpr: BIOPERATOR;
uniOperatorExpr: UNIOPERATOR;
localFncBodyExpr: SPACE? PSTART SPACE? 'let' SPACE? PSTART SPACE? ((PSTART SPACE? varPairExpr SPACE? PEND) SPACE?)* PEND
               SPACE? fncBodyExpr SPACE? PEND SPACE?;

fncBodyExpr: SPACE? ((expr | callFnc | ifExpr | setExpr | loopExpr | listExpr | displayExpr | vectorExpr) SPACE?)+ SPACE?;
varPairExpr: SPACE? identifier SPACE (expr | literal | identifier | callFnc | vectorExpr | listExpr) SPACE?;

setExpr: SPACE? PSTART SPACE? 'set!' SPACE varPairExpr SPACE? PEND SPACE?;
loopExpr: SPACE? PSTART SPACE? 'let' SPACE identifier SPACE? PSTART SPACE? ((PSTART SPACE? varPairExpr SPACE? PEND) SPACE?)* PEND
          SPACE? fncBodyExpr SPACE? PEND SPACE? ;

vectorExpr: SPACE? PSTART SPACE? 'vector' (SPACE (literal | identifier | expr))* SPACE? PEND SPACE? ;

listExpr: SPACE? PSTART SPACE? 'list' (SPACE (literal | identifier | vectorExpr | listExpr  | expr))* SPACE? PEND SPACE? ;

displayExpr: SPACE? PSTART SPACE? 'display' SPACE (literal | identifier | vectorExpr | listExpr | callFnc | expr | ifExpr) SPACE? PEND SPACE? ;

literal: FLOAT | INT | '-'FLOAT | '-'INT;
identifier: VARIABLE;

OPERATOR: [+*/-];
BIOPERATOR: '=' | '<=' | '>=' | '<' | '>' | '!=' | 'and' | 'or';
UNIOPERATOR: 'null?';
VARIABLE: [a-zA-Z][a-zA-Z-!]*[0-9]*;
PSTART: '(';
PEND: ')';
SPACE: [ ]+;
FLOAT: [0-9]+ '.' [0-9]+;
INT: [0-9]+;
WS: [ \t\r\n]+ -> skip;




(define board-state (list (vector 0 0 0 0 0 0 0) (vector 0 0 0 0 0 0 0) (vector 0 0 0 0 0 0 0) (vector 0 0 0 0 0 0 0) (vector 0 0 0 0 0 0 0) (vector 0 0 0 0 0 0 0)))
(define n-rows 7)


(define red (color 255 0 0 255))
(define white (color 255 255 255 255))
(define blue (color 0 0 200 255))
(define yellow (color 255 255 0 255))
(define token-radius 45)
(define board (canvas 700 600))
(define player 1)


(define (draw-token x y col)
(fill-arc board (+ 50 (* x 100)) (+ 50 (* y 100)) token-radius col))


(define (draw-token-row i j)
(if (<= j 7) (begin (draw-token j i white) (draw-token-row i (+ j 1))) ))


(define (draw-token-spaces i)
(if (<= i 6) (begin (draw-token-row i 0) (draw-token-spaces (+ i 1)))))


(define (draw-board)
(fill-rect board 0 0 700 600 blue)
(draw-token-spaces 0))


(draw-board)


(define (token-space-is-empty r c)
(if (> r 5) 0 (if (= (vector-ref (list-ref board-state r) c) 0) 1 0)))


(define (get-dir-token-count r c dr dc count)
(let ((nr (+ r dr)) (nc (+ c dc)))

(if (and (<= nr 5) (>= nr 0) (>= nc 0) (<= nc 6))
(if (= (vector-ref (list-ref board-state r) c) (vector-ref (list-ref board-state nr) nc))

(get-dir-token-count nr nc dr dc (+ 1 count))  count ) count)))

(define (check-dir r c dr dc)
(if (> (+ (get-dir-token-count r c dr dc 0) (get-dir-token-count r c (* -1 dr) (* -1 dc) 0)) 2) 1 0))


(define (check-four r c)
(if (= (check-dir r c 0 1) 1) 1
(if (= (check-dir r c 1 0) 1) 1
(if (= (check-dir r c 1 -1) 1) 1
(if (= (check-dir r c 1 1) 1) 1 0)))))

(define (new-game) (display 123456))


(define (put-token r c)
(if (= player 1)
(begin (draw-token c r red) (set! player 2) (vector-set! (list-ref board-state r) c 2))
(begin (draw-token c r yellow) (vector-set! (list-ref board-state r) c 1) (set! player 1)))
(if (= (check-four r c) 1) (begin (if (= player 2) (fill-text board (vector 82 69 68 32 87 79 78 33) 250 250)
(fill-text board (vector 89 69 76 76 79 87 32 87 79 78 33) 250 250))
(canvas-onclick board new-game)
)))




(define (click x y)
(let ((c (quotient (ceiling x) 100))(r (quotient (ceiling y) 100)))
(if (and (= (token-space-is-empty r c) 1) (= (token-space-is-empty (+ r 1) c) 0))  (put-token r c))))

(canvas-onclick board click)





---------------------------------------------------------------------------------------------
grammar SchemeLikeL;

start: SPACE? (expr | defineGlobalVar | defineFnc | literal | identifier | callFnc | setExpr | listExpr | vectorExpr | displayExpr | uniExpr)+ EOF;

expr: SPACE? PSTART SPACE? operatorExpr (SPACE (expr | literal | identifier | callFnc | uniExpr | biExpr ))+ SPACE? PEND SPACE?;
defineGlobalVar: SPACE? PSTART SPACE? 'define' SPACE identifier (SPACE (expr | literal | identifier | callFnc | vectorExpr | listExpr))+ SPACE? PEND SPACE?;
defineFnc: SPACE? PSTART SPACE? 'define' SPACE
        ((PSTART identifier (SPACE identifier)* SPACE? PEND SPACE? (fncBodyExpr | localFncBodyExpr) PEND) |
        (identifier SPACE? PSTART SPACE? 'lambda' SPACE? PSTART SPACE? identifier? (SPACE identifier)* SPACE? PEND
        SPACE? fncBodyExpr PEND PEND));
biExpr: SPACE? PSTART SPACE? biOperatorExpr SPACE (biExpr | expr | literal | identifier | callFnc | uniExpr) SPACE
        (biExpr | expr | literal | identifier | callFnc) SPACE? PEND SPACE?;
uniExpr: SPACE? PSTART SPACE? uniOperatorExpr SPACE (literal | identifier | expr | callFnc) SPACE? PEND SPACE?;


callFnc: SPACE? PSTART SPACE? identifier (SPACE (expr | identifier | literal  | callFnc | callLambdaFnc | listExpr | vectorExpr))* SPACE? PEND SPACE?;
callLambdaFnc: SPACE? PSTART SPACE? 'lambda' SPACE? PSTART SPACE? identifier? (SPACE identifier)* SPACE? PEND
                       SPACE? ((expr | callFnc) SPACE?)+ PEND SPACE?;
ifExpr: SPACE? PSTART SPACE? 'if' SPACE (expr | biExpr | literal | identifier | callFnc | uniExpr)
        SPACE? ((expr | literal | identifier | callFnc | setExpr | ifExpr | displayExpr ) | beginExpr)
        (SPACE? ((expr | literal | identifier | callFnc | setExpr | ifExpr | displayExpr ) | beginExpr))? SPACE? PEND SPACE?;

beginExpr: SPACE? PSTART SPACE? 'begin' SPACE?  (expr | literal | identifier | callFnc | setExpr | displayExpr | ifExpr)+  SPACE? PEND SPACE?;

operatorExpr: OPERATOR;
biOperatorExpr: BIOPERATOR;
uniOperatorExpr: UNIOPERATOR;
localFncBodyExpr: SPACE? PSTART SPACE? 'let' SPACE? PSTART SPACE? ((PSTART SPACE? varPairExpr SPACE? PEND) SPACE?)* PEND
               SPACE? fncBodyExpr SPACE? PEND SPACE?;

fncBodyExpr: SPACE? ((expr | callFnc | ifExpr | setExpr  | listExpr | displayExpr | vectorExpr) SPACE?)+ SPACE?;
varPairExpr: SPACE? identifier SPACE (expr | literal | identifier | callFnc | vectorExpr | listExpr | uniExpr | biExpr) SPACE?;

setExpr: SPACE? PSTART SPACE? 'set!' SPACE varPairExpr SPACE? PEND SPACE?;

vectorExpr: SPACE? PSTART SPACE? 'vector' (SPACE (literal | identifier | expr))* SPACE? PEND SPACE? ;

listExpr: SPACE? PSTART SPACE? 'list' (SPACE (literal | identifier | vectorExpr | listExpr  | expr))* SPACE? PEND SPACE? ;

displayExpr: SPACE? PSTART SPACE? 'display' SPACE (literal | identifier | vectorExpr | listExpr | callFnc | expr | ifExpr | uniExpr | biExpr ) SPACE? PEND SPACE? ;


literal: FLOAT | INT | NFLOAT | NINT   ;
identifier: VARIABLE;

OPERATOR: [-+*/] | 'and' | 'or';
BIOPERATOR: '=' | '<=' | '>=' | '<' | '>' | '!=' | 'quotient';
UNIOPERATOR: 'null?' | 'floor' | 'round' | 'ceiling' | 'truncate';
VARIABLE: [a-zA-Z][a-zA-Z-!]*[0-9]*;
PSTART: '(';
PEND: ')';
SPACE: [ ]([ ]|'\n')*;
FLOAT: [0-9]+ '.' [0-9]+;
INT: [0-9]+;
NFLOAT: '-'FLOAT;
NINT: '-'INT;
WS: [ \t\r\n]+ -> skip;



///drop
(define (f)(display "Hello World"))
(define (g a) (display "lala") (+ a 10))

(define (l) (g 30) (f) )
(display (l))


/////////////////////////////////////////
(define (factorial n)
(if (= n 0) 1
(* n (factorial (- n 1)))))


(define (sum-of-factorial-of-digits num acc)
(if (= num 0) acc
(sum-of-factorial-of-digits (quotient num 10)
    (+ acc (factorial (remainder num 10))))))

(define (is-peterson-number n)
(if (= n (sum-of-factorial-of-digits n 0))  1 0))

(display (is-peterson-number 145))

(export is-peterson-number)
//////////////////////////////////////////





npm install assemblyscript
npx asc index.ts -o myWasm.wasm -b esm --optimize -optimizeLevel 2

