<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>My Wasm</title>
<meta name="viewport" content="width=device-width,initial-scale=1">

<style>
    .canvas-container {
        margin-right: 20px;
        text-align: center;
        display: inline-block;
    }



</style>
  </head>
<body>
<div class="canvas-container">
    <h2>Lory</h2>
    <canvas id="canvas1" width="500" height="500"></canvas>
</div>
<div class="canvas-container">
    <h2>JavaScript</h2>
    <canvas id="canvas2" width="500" height="500"></canvas>
</div>

<p>N. vectors: <span id="sliderValue">20</span></p>
<input type="range" id="slider" name="slider" min="20" max="20000" value="20" step="20">

<p>N. iterations: <span id="sliderValue2">10</span></p>
<input type="range" id="slider2" name="slider2" min="0" max="100" value="10" step="5">

<button id="btn">Run</button>
<script>

    const sliderVector = document.getElementById('slider');
    const outputVector = document.getElementById('sliderValue');
    const sliderIterations = document.getElementById('slider2');
    const outputIterations = document.getElementById('sliderValue2');
    const btn = document.getElementById('btn');
    let canAnimate = true;


    sliderVector.addEventListener('input', function() {
        outputVector.textContent = sliderVector.value;
    });

    sliderIterations.addEventListener('input', function() {
        outputIterations.textContent = sliderIterations.value;
    });


    btn.addEventListener('click', function() {
        if (canAnimate) animation(sliderVector.value, sliderIterations.value)
    });


    class Time {
        constructor() {
            this.time = performance.now();
        }
        end() {
            return (performance.now() - this.time).toFixed(3); // round number to lower decimal precision, like console.time()
        }
    }




    // init wasm canvas
    let canvas = document.getElementById("canvas1")
    let ctx = canvas.getContext('2d');
    ctx.fillStyle = '#f0f0f0';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // init js canvas
    let canvas2 = document.getElementById("canvas2")
    let ctx2 = canvas2.getContext('2d');
    ctx2.fillStyle = '#f0f0f0';
    ctx2.fillRect(0, 0, canvas2.width, canvas2.height);

    memory = new WebAssembly.Memory({initial:100, maximum: 65536});
    mem_i32 = new Int32Array(memory.buffer);
    mem_f32 = new Float32Array(memory.buffer);

    let exports;
    let canvasMap = new Map();


    const importObject = {
        env: {
            memory: memory,
            throwError: throwError,
            displayNumber: displayNumber,
            displayList: displayList,
            displayVec: displayVec,
            displayUndef: displayUndef,
            newline: newline,
            createCanvasElement: createCanvasElement,
            updateCanvasData: updateCanvasData,
            canvasFillText: canvasFillText,
            addCanvasOnClickListener: addCanvasOnClickListener,
        }};



    WebAssembly.instantiateStreaming( fetch('binary.wasm'), importObject)
        .then(obj => {
            obj.instance.exports.main();
            exports = obj.instance.exports
        }).catch(error => {
            console.error(error)
        });

    function animation(n_vectors, n_iterations) {
        canAnimate = false;
        // generate vectors and store them to mem_f32

        let size = n_vectors*2;
        populateWasmMemory(size)
        let pertPointers = [6+size, 7+2*size, 8+3*size]

        //copy vector from mem_f32 to js array
        let vectors = [];
        for (let i = 0; i < size ; i++) {
            vectors.push( mem_f32[i+6]);
        }

        //copy perturbation vectors from mem_f32 to js arrays
        let p1 = [];
        let p2 = [];
        let p3 = [];
        for (let i = 0; i < size ; i++) {
            p1.push( mem_f32[i+7+size]);
            p2.push(  mem_f32[i+8+2*size]);
            p3.push(  mem_f32[i+9+3*size]);
        }
        let pertArrays = [p1, p2, p3];

        //sequence of perturbations
        let pertIndices = [];
        for (let i = 0; i < 100; i++) {
            pertIndices.push(Math.floor(Math.random() * 2))
        }

        let i = 0;
        // console.time("wasm")
        // let t = performance.now();

        animate()



        function animate() {
            mem_i32[1] = 0;
            mem_i32[2] = 0;
            mem_i32[3] = 0;
            mem_i32[4] = 0;

            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle  = 'black';
            for (let i = 6; i < 6+size; i+= 2) {
                ctx.beginPath();
                ctx.moveTo(250,250);
                ctx.lineTo(mem_f32[i]+250, mem_f32[i+1]+250);
                ctx.stroke();
            }


            let index = pertIndices[i];
            let permPointer = pertPointers[index];
            let permPointerWasm = (4*(permPointer) << 2) | 3;
            let vectPointerWasm = (4*5 << 2) | 3;

            console.time("wasm")
            // let start= performance.now()
            exports.ff(3, vectPointerWasm, permPointerWasm, 0)
            //     exports.f(3, vectPointerWasm)
            // exports.add2( vectPointerWasm , permPointerWasm  )
            // let diff = Date.now() - start;
            // console.log(diff)
            // console.log((performance.now() - start).toFixed(20))
             console.timeEnd("wasm")


            ctx.strokeStyle = 'red';
            ctx.beginPath();
            ctx.moveTo(250,250);
            ctx.lineTo(mem_f32[1]+250, mem_f32[2]+250);
            ctx.stroke();
            i++
            if (i < n_iterations) setTimeout(()=> animate(), 100)
            else  {
                // let endTime = performance.now();
                //
                // console.timeEnd("wasm")
                // console.log(endTime-t)
                i = 0;
                // console.time("JS");
                // t = performance.now();
                animateJs();
            }
        }


        function animateJs() {
            ctx2.fillStyle = '#f0f0f0';
            ctx2.fillRect(0, 0, canvas2.width, canvas2.height);
            ctx2.strokeStyle  = 'black';
            for (let i = 0; i < vectors.length; i+= 2) {
                ctx2.beginPath();
                ctx2.moveTo(250,250);
                ctx2.lineTo(vectors[i]+250, vectors[i+1]+250);
                ctx2.stroke();
            }

            let index = pertIndices[i];
            let pertArray = pertArrays[index];
            let x = 0;
            let y = 0;

            console.time("JS");

            for(let i = 0; i < size ; i+=2) {
                x += vectors[i];
            }
            x /= n_vectors;
            for(let i = 1; i < size; i+=2) {
                y += vectors[i];
            }
            y /= n_vectors;
            for(let i = 0; i < pertArray.length; i++) {
                vectors[i] += pertArray[i];
            }
            console.timeEnd("JS");


            ctx2.strokeStyle = 'red';
            ctx2.beginPath();
            ctx2.moveTo(250,250);
            ctx2.lineTo(x+250, y+250);
            ctx2.stroke();

            i++;
            if (i < n_iterations) setTimeout(()=> animateJs(), 100)
            else {
                // let endTime = performance.now();
                //
                // console.timeEnd("JS");
                // console.log(endTime-t)
                canAnimate = true;
            }
        }
    }


    function populateWasmMemory(size) {
        //result vector
        mem_i32[0] = 4;
        mem_i32[1] = 0;
        mem_i32[2] = 0;
        mem_i32[3] = 0;
        mem_i32[4] = 0;

        //generate vectors and store them as one vector
        mem_i32[5] = size;
        let rad = 100
        for (let i = 6; i < 6 + size ; i++) {
            mem_f32[i] = Math. floor(Math. random() * (rad - -rad + 1)) -rad;
        }

        //generate first perturbation vector
        mem_i32[6+size] = size;
        for (let i = 7+size; i < 7 + 2* size ; i++) {
            mem_f32[i] = Math.floor(Math. random() * (10 - -10 + 1)) -10;
            mem_f32[i+1] = Math.floor(Math. random() * (10 - -10 + 1)) -10
        }

        //generate second perturbation vector
        mem_i32[7+2*size] = size;
        for (let i = 8+2*size; i < 8 + 3* size ; i++) {
            mem_f32[i] = Math.floor(Math. random() * (10 - -10 + 1)) -10;
            mem_f32[i+1] = Math.floor(Math. random() * (10 - -10 + 1)) -10
        }

        //generate third perturbation vector
        mem_i32[8+3*size] = size;
        for (let i = 9+3*size; i < 9 + 4* size ; i++) {
            mem_f32[i] = Math.floor(Math. random() * (10 - -10 + 1)) -10;
            mem_f32[i+1] = Math.floor(Math. random() * (10 - -10 + 1)) -10
        }
    }


    function toWasmNumber(value) {
        return new Uint32Array(new Float32Array([value]).buffer)[0] & -2;
    }

    function fromWasmNumber(value) {
        return new Float32Array(new Uint32Array ([value]).buffer)[0];
    }


    const ErrorType = {
        ExpectedNumberActualList: 0,
        ExpectedNumberActualVector: 1,
        ExpectedListActualVector: 2,
        ExpectedListActualNumber: 3,
        ExpectedVectorActualList: 4,
        ExpectedVectorActualNumber: 5,
        ExpectedNumberActualVoid: 6,
        ExpectedListActualVoid: 7,
        ExpectedVectorActualVoid: 8,
        ExpectedListActualEmpty: 9,
        ExpectedVectorActualEmpty: 10,
        IndexOutOfBounds: 11,
    }


    function throwError(value) {

        switch (value) {
            case ErrorType.ExpectedNumberActualList:
                throw new TypeError("expected type: Number, actual type: List");
            case ErrorType.ExpectedNumberActualVector:
                throw new TypeError("expected type: Number, actual type: Vector");
            case ErrorType.ExpectedListActualVector:
                throw new TypeError("expected type: List, actual type: Vector");
            case ErrorType.ExpectedListActualNumber:
                throw new TypeError("expected type: List, actual type: Number");
            case ErrorType.ExpectedVectorActualList:
                throw new TypeError("expected type: Vector, actual type: List");
            case ErrorType.ExpectedVectorActualNumber:
                throw new TypeError("expected type: Vector, actual type: Number");
            case ErrorType.ExpectedVectorActualVoid:
                throw new TypeError("expected type: Vector, actual type: Void");
            case ErrorType.ExpectedListActualVoid:
                throw new TypeError("expected type: List, actual type: Void");
            case ErrorType.ExpectedNumberActualVoid:
                throw new TypeError("expected type: Number, actual type: Void");
            case ErrorType.ExpectedListActualEmpty:
                throw new Error("cannot perform the operation on an empty List");
            case ErrorType.ExpectedVectorActualEmpty:
                throw new Error("cannot perform the operation on an empty Vector");
            case ErrorType.IndexOutOfBounds:
                throw new Error("index out of bounds");
            default:
                throw new Error("unspecified error")
        }
    }

    function createCanvasElement(address, width, height) {
        let canvas = document.createElement('canvas');
        canvas.height = height;
        canvas.width = width;
        document.body.appendChild(canvas);
        canvasMap.set(address, {canvas: canvas, clickHandler: undefined });
    }

    function updateCanvasData(address) {
        let canvas = canvasMap.get(address).canvas;
        let width = mem_f32[address/4];
        let height = mem_f32[address/4 + 1];
        const image_data = new ImageData( new Uint8ClampedArray(mem_i32.buffer, address + 8,
            width*height*4), width, height);
        canvas.getContext('2d').putImageData(image_data, 0, 0);
    }


    function addCanvasOnClickListener(address, fncNum) {
        let canvas = canvasMap.get(address).canvas;
        let clickHandler = canvasMap.get(address).clickHandler;
        if (clickHandler) {
            canvas.removeEventListener('click',  clickHandler);
        }
        clickHandler = (e) => {
            const rect = canvas.getBoundingClientRect()
            const x = e.clientX - rect.left
            const y = e.clientY - rect.top
            let xValue = new Uint32Array(new Float32Array([x]).buffer)[0] & -2;
            let yValue = new Uint32Array(new Float32Array([y]).buffer)[0] & -2;
            Object.entries(exports).at(fncNum).at(1)(xValue, yValue);
        };
        canvasMap.get(address).clickHandler = clickHandler;
        canvas.addEventListener('click', clickHandler);
    }

    function canvasFillText(address, vector, x, y) {
        let canvas = canvasMap.get(address).canvas;
        let text = "";
        let pointer = vector >> 2;
        let length = mem_i32[pointer/4];
        for (let i = 1; i <= length; i++) {
            text += String.fromCharCode(mem_f32[(pointer+i*4)/4]);
        }
        let x_pos = new Float32Array(new Uint32Array([x]).buffer)[0];
        let y_pos = new Float32Array(new Uint32Array([y]).buffer)[0];
        let ctx = canvas.getContext('2d');
        ctx.font = "bold 30px Arial";
        ctx.fillText(text, x_pos, y_pos);
    }

    function newline() {
        console.log('\n')
    }

    function displayNumber(value) {
        console.log(value)
    }

    function displayList(listPointer) {
        let list = "(";
        let stack = [];

        let pointer = listPointer >> 2;
        while (true) {
            if (pointer === -1) {
                if (stack.length > 0) {
                    pointer = stack.pop();
                    list += ")";
                    if (pointer !== -1) list += " ";
                    continue;
                } else {
                    list += ")";
                    console.log(list);
                    break;
                }

            }
            if ((mem_i32[pointer/4] & 1) === 1 ) {
                if ((mem_i32[pointer/4] & 3) === 3 ) {
                    list += "#("
                    let point = mem_i32[pointer/4] >> 2;
                    let length = mem_i32[point/4];
                    for (let i = 1; i <= length; i++) {
                        list += mem_f32[(point+i*4)/4];
                        if (i !== length) list += " ";
                    }
                    list += ")"
                }
                else {
                    stack.push( mem_i32[(pointer +4) / 4]);
                    list += "(";
                    pointer = mem_i32[pointer / 4] >> 2;
                    continue;
                }
            } else {
                list += mem_f32[pointer/4];
            }
            pointer = mem_i32[(pointer + 4)/4];
            if (pointer !== -1) {
                list += " ";
            }
        }
    }


    function displayVec(vectorPointer) {
        let vector = "#("
        let pointer = vectorPointer >> 2;
        let length = mem_i32[pointer/4];
        for (let i = 1; i <= length; i++) {
            vector += mem_f32[(pointer+i*4)/4];
            if (i !== length) {
                vector += " "
            }
        }
        vector += ")"
        console.log(vector)
    }

    function displayUndef() {
        console.log("#<undef>")
    }





</script>

</body>
</html>